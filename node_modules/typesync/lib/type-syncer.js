"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTypeSyncer = createTypeSyncer;
const path = __importStar(require("node:path"));
const types_1 = require("./types");
const util_1 = require("./util");
const versioning_1 = require("./versioning");
/**
 * Creates a type syncer.
 *
 * @param packageJSONservice
 * @param typeDefinitionSource
 */
function createTypeSyncer(packageJSONService, workspaceResolverService, packageSource, configService, globber) {
    const fetchPackageInfo = (0, util_1.memoizeAsync)(packageSource.fetch);
    return {
        sync,
    };
    /**
     * Syncs typings in the specified package.json.
     */
    async function sync(filePath, flags) {
        const dryRun = !!flags.dry;
        const syncOpts = await configService.readConfig(filePath, flags);
        const { file, subManifests } = await getManifests(filePath, globber, syncOpts.ignoreProjects ?? []);
        const syncedFiles = await Promise.all([
            syncFile(filePath, file, syncOpts, dryRun),
            ...subManifests.map((p) => syncFile(p, null, syncOpts, dryRun)),
        ]);
        return {
            syncedFiles,
        };
    }
    /**
     * Get the `package.json` files and sub-packages.
     *
     * @param filePath
     * @param globber
     */
    async function getManifests(filePath, globber, ignoredWorkspaces) {
        const file = await packageJSONService.readPackageFile(filePath);
        const subPackages = await workspaceResolverService.getWorkspaces(file, path.dirname(filePath), globber, ignoredWorkspaces);
        const subManifests = subPackages.map((p) => path.join(p, 'package.json'));
        return {
            file,
            subManifests,
        };
    }
    /**
     * Syncs a single file.
     *
     * @param filePath
     * @param file
     * @param allTypings
     * @param opts
     */
    async function syncFile(filePath, file, opts, dryRun) {
        const { ignoreDeps, ignorePackages } = opts;
        const packageFile = file ?? (await packageJSONService.readPackageFile(filePath));
        const allLocalPackages = Object.values(types_1.IDependencySection)
            .map((dep) => {
            const section = getDependenciesBySection(packageFile, dep);
            const ignoredSection = ignoreDeps?.includes(dep);
            return getPackagesFromSection(section, ignoredSection, ignorePackages);
        })
            .flat();
        const allPackageNames = (0, util_1.uniq)(allLocalPackages.map((p) => p.name));
        const potentiallyUntypedPackages = getPotentiallyUntypedPackages(allPackageNames);
        // This is pushed to in the inner `map`, because packages that have DT-typings
        // *as well* as internal typings should be excluded.
        const used = [];
        const devDepsToAdd = await Promise.all(potentiallyUntypedPackages.map(async (t) => {
            // Fetch the code package from the source.
            const typePackageInfoPromise = fetchPackageInfo(t.typesPackageName);
            const codePackageInfo = await fetchPackageInfo(t.codePackageName);
            // If the code package was not found, there's nothing else to do.
            if (!codePackageInfo) {
                return {};
            }
            const localCodePackage = allLocalPackages.find((p) => p.name === t.codePackageName);
            // Find the closest matching code package version relative to what's in our package.json
            const closestMatchingCodeVersion = (0, versioning_1.getClosestMatchingVersion)(codePackageInfo.versions, localCodePackage.version);
            // If the closest matching version contains internal typings, don't include it.
            if (closestMatchingCodeVersion.containsInternalTypings) {
                return {};
            }
            // Look for the closest matching typings package.
            const typePackageInfo = await typePackageInfoPromise;
            // If the types package was not found, or if it was deprecated, there's nothing else to do.
            if (!typePackageInfo || typePackageInfo.deprecated) {
                return {};
            }
            // Gets the closest matching typings version, or the newest one.
            const closestMatchingTypingsVersion = (0, versioning_1.getClosestMatchingVersion)(typePackageInfo.versions, localCodePackage.version);
            const version = closestMatchingTypingsVersion.version;
            const semverRangeSpecifier = '~';
            used.push(t);
            return {
                [t.typesPackageName]: semverRangeSpecifier + version,
            };
        })).then(util_1.mergeObjects);
        const devDeps = packageFile.devDependencies;
        if (!dryRun) {
            await packageJSONService.writePackageFile(filePath, {
                ...packageFile,
                devDependencies: (0, util_1.orderObject)({
                    ...devDepsToAdd,
                    ...devDeps,
                }),
            });
        }
        return {
            filePath,
            newTypings: used,
            package: packageFile,
        };
    }
}
/**
 * Returns an array of packages that do not have a `@types/` package.
 *
 * @param allPackageNames Used to filter the typings that are new.
 * @param allTypings All typings available
 */
function getPotentiallyUntypedPackages(allPackageNames) {
    const existingTypings = allPackageNames.filter((x) => x.startsWith('@types/'));
    return (0, util_1.filterMap)(allPackageNames, (p) => {
        // Ignore typings packages themselves.
        if (p.startsWith('@types/')) {
            return false;
        }
        const typingsName = getTypingsName(p);
        const fullTypingsPackage = (0, util_1.typed)(p);
        const alreadyHasTyping = existingTypings.some((t) => t === fullTypingsPackage);
        if (alreadyHasTyping) {
            return false;
        }
        return {
            typingsName: typingsName,
            typesPackageName: fullTypingsPackage,
            codePackageName: p,
        };
    });
}
/**
 * Gets the typings name for the specified package name.
 * For example, `koa` would be `koa`, but `@koa/router` would be `koa__router`.
 *
 * @param packageName the package name to generate the typings name for
 */
function getTypingsName(packageName) {
    const scopeInfo = getPackageScope(packageName);
    let typingsName = packageName;
    if (scopeInfo && scopeInfo[0] !== 'types') {
        typingsName = `${scopeInfo[0]}__${scopeInfo[1]}`;
    }
    return typingsName;
}
/**
 * If a package is scoped, returns the scope + package as a tuple, otherwise null.
 *
 * @param packageName Package name to check scope for.
 */
function getPackageScope(packageName) {
    const EXPR = /^@([^/]+)\/(.*)$/i;
    const matches = EXPR.exec(packageName);
    if (!matches) {
        return null;
    }
    return [matches[1], matches[2]];
}
/**
 * Get packages from a dependency section
 *
 * @param section
 * @param ignoredSection
 * @param ignorePackages
 */
function getPackagesFromSection(section, ignoredSection, ignorePackages) {
    return (0, util_1.filterMap)(Object.keys(section), (name) => {
        const isTyping = name.startsWith('@types/');
        // Never ignore `@types` packages.
        if (!isTyping) {
            // If it's not a `@types` package, check whether the section or package is ignored.
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing -- We want to check for false as well.
            if (ignoredSection || ignorePackages?.includes(name)) {
                return false;
            }
        }
        return { name, version: section[name] };
    });
}
/**
 * Get dependencies from a package section
 *
 * @param file Package file
 * @param section Package section, eg: dev, peer
 */
function getDependenciesBySection(file, section) {
    const dependenciesSection = (() => {
        switch (section) {
            case types_1.IDependencySection.deps:
                return file.dependencies;
            case types_1.IDependencySection.dev:
                return file.devDependencies;
            case types_1.IDependencySection.optional:
                return file.optionalDependencies;
            case types_1.IDependencySection.peer:
                return file.peerDependencies;
        }
    })();
    return dependenciesSection ?? {};
}
//# sourceMappingURL=type-syncer.js.map