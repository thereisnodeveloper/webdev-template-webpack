"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startCli = startCli;
const path = __importStar(require("node:path"));
const awilix_1 = require("awilix");
const chalk_1 = __importDefault(require("chalk"));
const C = __importStar(require("./cli-util"));
const config_service_1 = require("./config-service");
const globber_1 = require("./globber");
const package_json_file_service_1 = require("./package-json-file-service");
const package_source_1 = require("./package-source");
const type_syncer_1 = require("./type-syncer");
const workspace_resolver_1 = require("./workspace-resolver");
const fsUtils = __importStar(require("./fs-utils"));
/**
 * Starts the TypeSync CLI.
 */
async function startCli() {
    try {
        // Awilix is a dependency injection container.
        const container = (0, awilix_1.createContainer)({
            injectionMode: awilix_1.InjectionMode.CLASSIC,
        }).register({
            packageJSONService: (0, awilix_1.asFunction)(package_json_file_service_1.createPackageJSONFileService).singleton(),
            workspaceResolverService: (0, awilix_1.asFunction)(() => (0, workspace_resolver_1.createWorkspaceResolverService)(fsUtils)).singleton(),
            packageSource: (0, awilix_1.asFunction)(package_source_1.createPackageSource).singleton(),
            configService: (0, awilix_1.asFunction)(config_service_1.createConfigService).singleton(),
            globber: (0, awilix_1.asFunction)(globber_1.createGlobber).singleton(),
            typeSyncer: (0, awilix_1.asFunction)(type_syncer_1.createTypeSyncer),
        });
        await run(container.resolve('typeSyncer'));
    }
    catch (err) {
        C.error(err);
        process.exitCode = 1;
    }
}
/**
 * Actual CLI runner. Uses the `syncer` instance to sync.
 * @param syncer
 */
async function run(syncer) {
    const { args, flags } = C.parseArguments(process.argv.slice(2));
    const [filePath = 'package.json'] = args;
    if (flags.help) {
        printHelp();
        return;
    }
    C.log((0, chalk_1.default) `TypeSync v{white ${require('../package.json').version}}`);
    if (flags.dry) {
        C.log('â€”â€” DRY RUN â€” will not modify file â€”â€”');
    }
    const result = await C.spinWhile(`Syncing type definitions in ${chalk_1.default.cyan(filePath)}...`, () => syncer.sync(filePath, flags));
    const syncedFilesOutput = result.syncedFiles
        .map(renderSyncedFile)
        .join('\n\n');
    const totals = result.syncedFiles
        .map((f) => ({
        newTypings: f.newTypings.length,
    }))
        .reduce((accum, next) => ({
        newTypings: accum.newTypings + next.newTypings,
    }), { newTypings: 0 });
    const syncMessage = (0, chalk_1.default) `\n\n${syncedFilesOutput}\n\nâœ¨  Run {green typesync} again without the {gray --dry} flag to update your {gray package.json}.`;
    if (flags.dry === 'fail' && totals.newTypings > 0) {
        C.error('Typings changed; check failed.');
        C.log(syncMessage);
        process.exitCode = 1;
        return;
    }
    C.success(totals.newTypings === 0
        ? `No new typings to add, looks like you're all synced up!`
        : flags.dry
            ? (0, chalk_1.default) `${totals.newTypings.toString()} new typings can be added.${syncMessage}`
            : (0, chalk_1.default) `${totals.newTypings.toString()} new typings added.\n\n${syncedFilesOutput}\n\nâœ¨  Go ahead and run {green npm install}, {green yarn}, or {green pnpm i} to install the packages that were added.`);
}
/**
 * Renders a type definition.
 * @param typeDef
 * @param isLast
 */
function renderTypeDef(typeDef, isLast) {
    const treeNode = isLast ? 'â””â”€' : 'â”œâ”€';
    return (0, chalk_1.default) `${treeNode} ${(0, chalk_1.default) `{green.bold +}`} {gray @types/}${(0, chalk_1.default) `{bold.blue ${typeDef.typingsName}}`}`;
}
/**
 * Renders a synced file.
 *
 * @param file
 */
function renderSyncedFile(file) {
    const badge = file.newTypings.length === 0
        ? (0, chalk_1.default) `{blue.bold (no new typings added)}`
        : (0, chalk_1.default) `{green.bold (${file.newTypings.length.toString()} new typings added)}`;
    const dirName = path.basename(path.dirname(path.resolve(file.filePath)));
    const title = (0, chalk_1.default) `ðŸ“¦ ${file.package.name ?? dirName} {gray.italic â€” ${file.filePath}} ${badge}`;
    const nl = '\n';
    const combined = [...file.newTypings.map((t) => ({ ...t, action: 'add' }))];
    const rendered = title +
        nl +
        combined
            .map((t) => renderTypeDef(t, combined[combined.length - 1] === t))
            .join(nl);
    return rendered;
}
/**
 * Prints the help text.
 */
function printHelp() {
    console.log((0, chalk_1.default) `
{blue.bold typesync} - adds missing TypeScript definitions to package.json

Options
  {magenta.bold --dry}                                   dry run, won't save the package.json
  {magenta.bold --ignoredeps=<deps|dev|peer|optional>}   ignores dependencies in the specified sections (comma separate for multiple). Example: {magenta ignoredeps=dev,peer}
  {magenta.bold --help}                                  shows this help menu
  `.trim());
}
//# sourceMappingURL=cli.js.map