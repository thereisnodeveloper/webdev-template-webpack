"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uniq = uniq;
exports.filterMap = filterMap;
exports.shrinkObject = shrinkObject;
exports.mergeObjects = mergeObjects;
exports.typed = typed;
exports.untyped = untyped;
exports.orderObject = orderObject;
exports.memoizeAsync = memoizeAsync;
exports.ensureWorkspacesArray = ensureWorkspacesArray;
/**
 * Returns unique items.
 *
 * @param source The source to filter
 */
function uniq(source) {
    return [...new Set(source)];
}
/**
 * Does a `map` and a `filter` in one pass.
 *
 * @param source The source to filter and map
 * @param iteratee The iteratee.
 */
function filterMap(source, iteratee) {
    const result = [];
    let index = 0;
    for (const item of source) {
        const mapped = iteratee(item, index++);
        if (mapped === false)
            continue;
        result.push(mapped);
    }
    return result;
}
/**
 * Remove blank attributes in a object.
 *
 * @param source
 */
function shrinkObject(source) {
    const object = {};
    for (const key in source) {
        if (typeof source[key] !== 'undefined') {
            object[key] = source[key];
        }
    }
    return object;
}
/**
 * Merges a sequence of objects into a single object using `reduce`.
 *
 * @param source An array of objects to merge.
 */
function mergeObjects(source) {
    return source.reduce((accum, next) => ({ ...accum, ...next }), {});
}
/**
 * Returns the assumed types package name.
 * @param name Package name
 */
function typed(name) {
    // If the package is scoped, the typings scheme is slightly different.
    if (/^@.*?\//i.test(name)) {
        const splat = name.split('/');
        return `@types/${splat[0].slice(1)}__${splat[1]}`;
    }
    return `@types/${name}`;
}
/**
 * Returns the assumed code package name based on a types package name.
 * @param name
 */
function untyped(name) {
    const prefix = '@types/';
    if (!name.startsWith(prefix)) {
        return name;
    }
    name = name.substring(prefix.length);
    const splat = name.split('__');
    if (splat.length === 2) {
        return `@${splat[0]}/${splat[1]}`;
    }
    return name;
}
/**
 * Orders an object.
 * @param source
 */
function orderObject(source, comparer) {
    const keys = Object.keys(source).sort(comparer);
    const result = {};
    for (const key of keys) {
        result[key] = source[key];
    }
    return result;
}
/**
 * Async memoize.
 *
 * @param fn
 */
function memoizeAsync(fn) {
    const cache = new Map();
    async function run(...args) {
        try {
            return await fn(...args);
        }
        catch (err) {
            cache.delete(args[0]);
            throw err;
        }
    }
    return async function (...args) {
        const key = args[0];
        if (cache.has(key)) {
            return cache.get(key);
        }
        const p = run(...args);
        cache.set(key, p);
        return p;
    };
}
/**
 * Ensures that we have a valid workspaces array.
 *
 * @param data
 */
function ensureWorkspacesArray(data) {
    if (!data) {
        return [];
    }
    if (!Array.isArray(data)) {
        return ensureWorkspacesArray(data.packages);
    }
    if (!data.every((s) => typeof s === 'string')) {
        return [];
    }
    return data;
}
//# sourceMappingURL=util.js.map