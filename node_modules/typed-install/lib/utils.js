"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.guessPackageManager = exports.missingTypes = exports.getTypingInfo = exports.installWithTool = exports.formatPackageMessage = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const shelljs_1 = require("shelljs");
const got_1 = require("got");
const pkgDir = require("pkg-dir");
const debug_1 = require("debug");
const debug = debug_1.default('typedi');
const REGISTRY_URL = 'https://registry.npmjs.org';
// some packages are exceptions - they ship with types, but those are stubs for some reason
// if a package is in this set, then @types/x will always be installed
const EXCEPTION_PACKAGES = new Set(['jest']);
const formatPackageMessage = (message, packages) => {
    return packages.length !== 0
        ? `${message}:\n${packages.map(p => `  * ${p}`).join('\n')}`
        : '';
};
exports.formatPackageMessage = formatPackageMessage;
const parseOpts = (packageManager) => {
    const command = {
        npm: 'npm i',
        yarn: 'yarn add',
        pnpm: 'pnpm i'
    }[packageManager];
    return {
        command,
        devFlag: '-D',
        exactFlag: '-E'
    };
};
const installWithTool = async (modules, { packageManager = 'npm', dev = false, exact = false } = {}) => {
    if (modules.length === 0) {
        return await Promise.resolve(null);
    }
    const { command, devFlag, exactFlag } = parseOpts(packageManager);
    return await new Promise((resolve, reject) => shelljs_1.exec([command, dev ? devFlag : '', exact ? exactFlag : '', ...modules].join(' '), 
    // yarn works when silent, but npm doesn't
    { async: true, silent: true }, (code, stdout, stderr) => {
        if (code !== 0) {
            reject(stderr);
        }
        resolve(stdout);
    }));
};
exports.installWithTool = installWithTool;
/**
 * gets the `@types/name` registry info
 */
const getTypingInfo = async (name) => {
    const url = `${REGISTRY_URL}/@${encodeURIComponent(`types/${name}`)}`;
    const response = await got_1.default(url, { throwHttpErrors: false });
    if (response.statusCode === 404) {
        return null;
    }
    else if (response.statusCode >= 400) {
        throw new Error(`trouble reading from registry: ${response.body}`);
    }
    return name;
};
exports.getTypingInfo = getTypingInfo;
/**
 * returns `null` for functions that have type info
 * returns the module name if types are missing
 */
const missingTypes = async (m) => {
    debug('looking at', m);
    if (EXCEPTION_PACKAGES.has(m)) {
        debug(m, 'is an exception, returning');
        return m;
    }
    const pkgRoot = await pkgDir();
    const installDir = path_1.resolve(`${pkgRoot !== null && pkgRoot !== void 0 ? pkgRoot : '.'}/node_modules/${m}`);
    try {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const pkg = require(`${installDir}/package.json`);
        // if the file exists at root, it doesn't need to be specified in pkg
        let orphanIndex = false;
        if (fs_1.existsSync(`${installDir}/index.d.ts`)) {
            orphanIndex = true;
        }
        if (pkg.typings !== undefined || pkg.types !== undefined || orphanIndex) {
            debug(m, 'has native types');
            return null;
        }
        else {
            debug(m, 'is missing types');
            return m;
        }
    }
    catch (e) {
        console.error('problem reading', m, '-', e);
        return null;
    }
};
exports.missingTypes = missingTypes;
const guessPackageManager = () => {
    if (fs_1.existsSync('./pnpm-lock.yaml')) {
        // lock file for pnpm
        return 'pnpm';
    }
    else if (fs_1.existsSync('./yarn.lock')) {
        // if there's a yarn lockfile, assume they want to use yarn
        return 'yarn';
    }
    else {
        return 'npm';
    }
};
exports.guessPackageManager = guessPackageManager;
