#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const lodash_1 = require("lodash");
const utils_1 = require("./utils");
const spinner_1 = require("./spinner");
const debug_1 = require("debug");
const chalk = require("chalk");
const debug = debug_1.default('typedi');
/* TESTING
 * asdfasdfasdfasdf doesn't exist at all
 * heroku-config has no types at all
 * lodash has types in @types
 * commander, striptags have included types (package.json)
 */
const prodDeps = 'dependencies';
const devDeps = 'devDependencies';
// inverted is whether a flag was passed in
// defaultDev is whether or not devDeps are the default if the first arg is false
const whichDeps = (inverted, defaultDev = false) => {
    if (inverted) {
        if (defaultDev) {
            return prodDeps;
        }
        return devDeps;
    }
    else {
        if (defaultDev) {
            return devDeps;
        }
        return prodDeps;
    }
};
exports.default = async (modules, { dev = false, prod = false, exact = false, 
// can't set a default value here (like npm) because we have custom fallback logic
packageManager } = {}, shouldSpin = false) => {
    const spinner = new spinner_1.Spinner(shouldSpin);
    // MAIN
    if (dev && prod) {
        spinner.log(`${chalk.redBright('WARNING')} using both --dev and --prod will probably not do what you expect`, true);
    }
    if (packageManager === undefined) {
        if (fs_1.existsSync('./pnpm-lock.yaml')) {
            // lock file for pnpm
            packageManager = 'pnpm';
        }
        else if (fs_1.existsSync('./yarn.lock')) {
            // if there's a yarn lockfile, assume they want to use yarn
            packageManager = 'yarn';
        }
        else {
            packageManager = 'npm';
        }
    }
    spinner.log(`Running using ${chalk.cyanBright(packageManager)}`);
    try {
        spinner.waitOn(`Installing Packages into ${chalk.cyanBright(whichDeps(Boolean(dev)))}`);
        await utils_1.installWithTool(modules, { dev, packageManager, exact });
    }
    catch (e) {
        spinner.fail(e);
        return;
    }
    spinner.succeed();
    const needsTypes = (await Promise.all(modules.map(utils_1.missingTypes))).filter(Boolean);
    debug('missing types:', needsTypes);
    spinner.waitOn('Checking for @types');
    const typesToFetch = (await Promise.all(needsTypes.map(utils_1.getTypingInfo))).filter(Boolean);
    spinner.succeed();
    debug('found @types for:', typesToFetch);
    try {
        spinner.waitOn(`Installing Available Types into ${chalk.cyanBright(whichDeps(Boolean(prod), true))}`);
        await utils_1.installWithTool(typesToFetch.map(t => `@types/${t}`), {
            dev: !prod,
            packageManager,
            exact
        });
    }
    catch (e) {
        spinner.fail(e);
        return;
    }
    spinner.succeed();
    const missing = lodash_1.difference(needsTypes, typesToFetch);
    const installed = lodash_1.difference(modules, missing);
    spinner.log(utils_1.formatPackageMessage(`\nThe following packages were ${chalk.greenBright.bold('fully installed')}`, installed));
    spinner.log(utils_1.formatPackageMessage(`${
    // need a leading newline if this is our first print statement
    installed.length !== 0 ? '' : '\n'}The following packages were installed, but ${chalk.yellowBright.bold('lack types')}`, missing));
};
